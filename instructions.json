
{
  "projectName": "Market Research Platform",
  "description": "Instructions for updating the project to add Countries and Services entities, update related services, add migrations, and improve utilities for better efficiency and production-readiness.",
  "tasks": [
    {
      "taskId": "add-entities",
      "description": "Add Countries and Services entities to the PostgreSQL schema without junction tables.",
      "actions": [
        {
          "action": "createFile",
          "filePath": "src/modules/entities/countries.entity.ts",
          "content": "import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity({ name: 'Countries' })\nexport class Country {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ type: 'varchar', length: '100', unique: true })\n  name: string;\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/modules/entities/services.entity.ts",
          "content": "import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity({ name: 'Services' })\nexport class Service {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ type: 'varchar', length: '100', unique: true })\n  name: string;\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/projects/entities/project.entity.ts",
          "instructions": "Replace the `country` column with a `countryId` foreign key referencing `Countries.id`. Keep `services_needed` as JSON for now. Add a ManyToOne relation to Country entity with RESTRICT on delete.",
          "content": "import { CURRENT_TIMESTAMP } from '../../../utils/constant';\nimport { Entity, Column, PrimaryGeneratedColumn, ManyToOne, JoinColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { Client } from '../../users/clients/entities/client.entity';\nimport { Country } from '../../entities/countries.entity';\nimport { ProjectStatus } from '../../../utils/enums';\n\n@Entity({ name: 'Projects' })\nexport class Project {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @ManyToOne(() => Country, { onDelete: 'RESTRICT' })\n  @JoinColumn({ name: 'countryId' })\n  country: Country;\n\n  @Column()\n  countryId: number;\n\n  @Column({ type: 'varchar', length: '200' })\n  title: string;\n\n  @Column({ type: 'text', nullable: true })\n  description: string;\n\n  @Column({ type: 'json' })\n  services_needed: string[];\n\n  @Column({ type: 'decimal', precision: 10, scale: 2 })\n  budget: number;\n\n  @Column({ type: 'varchar', length: '50', default: ProjectStatus.PENDING })\n  status: string;\n\n  @ManyToOne(() => Client, { onDelete: 'CASCADE' })\n  @JoinColumn({ name: 'clientId' })\n  client: Client;\n\n  @Column()\n  clientId: number;\n\n  @CreateDateColumn({ type: 'timestamp', default: () => CURRENT_TIMESTAMP })\n  createdAt: Date;\n\n  @UpdateDateColumn({\n    type: 'timestamp',\n    default: () => CURRENT_TIMESTAMP,\n    onUpdate: CURRENT_TIMESTAMP,\n  })\n  updatedAt: Date;\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/vendors/entities/vendor.entity.ts",
          "instructions": "Change `countries_supported` to JSON of number[] (Country IDs). Keep `services_offered` as JSON of strings for now.",
          "content": "import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';\nimport { CURRENT_TIMESTAMP } from '../../../utils/constant';\n\n@Entity({ name: 'Vendors' })\nexport class Vendor {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ type: 'varchar', length: '150' })\n  name: string;\n\n  @Column({ type: 'varchar', length: '250', unique: true })\n  email: string;\n\n  @Column({ type: 'json' })\n  countries_supported: number[];\n\n  @Column({ type: 'json' })\n  services_offered: string[];\n\n  @Column({ type: 'decimal', precision: 3, scale: 1 })\n  rating: number;\n\n  @Column({ type: 'float' })\n  response_sla_hours: number;\n\n  @CreateDateColumn({ type: 'timestamp', default: () => CURRENT_TIMESTAMP })\n  createdAt: Date;\n\n  @UpdateDateColumn({\n    type: 'timestamp',\n    default: () => CURRENT_TIMESTAMP,\n    onUpdate: CURRENT_TIMESTAMP,\n  })\n  updatedAt: Date;\n}"
        }
      ]
    },
    {
      "taskId": "update-services",
      "description": "Update services to handle the new Countries and Services entities, ensuring compatibility with PostgreSQL and MongoDB for Documents.",
      "actions": [
        {
          "action": "updateFile",
          "filePath": "src/modules/projects/projects.service.ts",
          "instructions": "Update ProjectsService to validate countryId against Countries table before creating/updating projects. Use TypeORM manager for validation.",
          "content": "import { Injectable, NotFoundException, InternalServerErrorException, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Project } from './entities/project.entity';\nimport { HandlerFactory } from '../../utils/handlerfactory/handler-factory.postgres';\nimport { Resource_Name, Models_Name } from '../../utils/enums';\n\n@Injectable()\nexport class ProjectsService {\n  private factory: HandlerFactory<Project>;\n  private readonly logger = new Logger(ProjectsService.name);\n\n  constructor(\n    @InjectRepository(Project)\n    private readonly projectRepository: Repository<Project>,\n  ) {\n    this.factory = new HandlerFactory<Project>(this.projectRepository);\n  }\n\n  async getAllProjects(query: any) {\n    return this.factory.getAll(query, Resource_Name.PROJECTS, Models_Name.PROJECT);\n  }\n\n  async getProjectById(id: number) {\n    try {\n      const project = await this.factory.getOne(id);\n      return project;\n    } catch (error) {\n      this.logger.error(`Failed to fetch project ID ${id}: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to fetch project');\n    }\n  }\n\n  async createProject(createProjectDto: any) {\n    try {\n      const country = await this.projectRepository.manager.findOne('Country', { where: { id: createProjectDto.countryId } });\n      if (!country) {\n        throw new NotFoundException(`Country ID ${createProjectDto.countryId} not found`);\n      }\n      return this.factory.create(createProjectDto);\n    } catch (error) {\n      this.logger.error(`Failed to create project: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to create project');\n    }\n  }\n\n  async updateProject(id: number, updateProjectDto: any) {\n    try {\n      if (updateProjectDto.countryId) {\n        const country = await this.projectRepository.manager.findOne('Country', { where: { id: updateProjectDto.countryId } });\n        if (!country) {\n          throw new NotFoundException(`Country ID ${updateProjectDto.countryId} not found`);\n        }\n      }\n      return this.factory.updateOne(id, updateProjectDto);\n    } catch (error) {\n      this.logger.error(`Failed to update project ID ${id}: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to update project');\n    }\n  }\n\n  async deleteProject(id: number) {\n    return this.factory.deleteOne(id);\n  }\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/vendors/vendors.service.ts",
          "instructions": "Update VendorsService to validate countries_supported as an array of Country IDs. Keep services_offered as string array for now.",
          "content": "import { Injectable, NotFoundException, InternalServerErrorException, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Vendor } from './entities/vendor.entity';\nimport { HandlerFactory } from '../../utils/handlerfactory/handler-factory.postgres';\nimport { Resource_Name, Models_Name } from '../../utils/enums';\n\n@Injectable()\nexport class VendorsService {\n  private factory: HandlerFactory<Vendor>;\n  private readonly logger = new Logger(VendorsService.name);\n\n  constructor(\n    @InjectRepository(Vendor)\n    private readonly vendorRepository: Repository<Vendor>,\n  ) {\n    this.factory = new HandlerFactory<Vendor>(this.vendorRepository);\n  }\n\n  async getAllVendors(query: any) {\n    return this.factory.getAll(query, Resource_Name.VENDORS, Models_Name.VENDOR);\n  }\n\n  async getVendorById(id: number) {\n    try {\n      const vendor = await this.factory.getOne(id);\n      return vendor;\n    } catch (error) {\n      this.logger.error(`Failed to fetch vendor ID ${id}: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to fetch vendor');\n    }\n  }\n\n  async createVendor(createVendorDto: any) {\n    try {\n      if (createVendorDto.countries_supported) {\n        const countries = await this.vendorRepository.manager.find('Country', { where: { id: In(createVendorDto.countries_supported) } });\n        if (countries.length !== createVendorDto.countries_supported.length) {\n          throw new NotFoundException('One or more country IDs not found');\n        }\n      }\n      return this.factory.create(createVendorDto);\n    } catch (error) {\n      this.logger.error(`Failed to create vendor: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to create vendor');\n    }\n  }\n\n  async updateVendor(id: number, updateVendorDto: any) {\n    try {\n      if (updateVendorDto.countries_supported) {\n        const countries = await this.vendorRepository.manager.find('Country', { where: { id: In(updateVendorDto.countries_supported) } });\n        if (countries.length !== updateVendorDto.countries_supported.length) {\n          throw new NotFoundException('One or more country IDs not found');\n        }\n      }\n      return this.factory.updateOne(id, updateVendorDto);\n    } catch (error) {\n      this.logger.error(`Failed to update vendor ID ${id}: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to update vendor');\n    }\n  }\n\n  async deleteVendor(id: number) {\n    return this.factory.deleteOne(id);\n  }\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/matches/matches.service.ts",
          "instructions": "Update MatchesService to handle countryId in project matching logic. Ensure services_offered is still a string array.",
          "content": "import { Injectable, NotFoundException, InternalServerErrorException, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Match } from './entities/match.entity';\nimport { Project } from '../projects/entities/project.entity';\nimport { Vendor } from '../vendors/entities/vendor.entity';\nimport { HandlerFactory } from '../../utils/handlerfactory/handler-factory.postgres';\nimport { Resource_Name, Models_Name } from '../../utils/enums';\n\n@Injectable()\nexport class MatchesService {\n  private factory: HandlerFactory<Match>;\n  private readonly logger = new Logger(MatchesService.name);\n\n  constructor(\n    @InjectRepository(Match)\n    private readonly matchRepository: Repository<Match>,\n    @InjectRepository(Project)\n    private readonly projectRepository: Repository<Project>,\n    @InjectRepository(Vendor)\n    private readonly vendorRepository: Repository<Vendor>,\n  ) {\n    this.factory = new HandlerFactory<Match>(this.matchRepository);\n  }\n\n  async rebuildMatches(projectId: number) {\n    try {\n      const project = await this.projectRepository.findOne({ where: { id: projectId }, relations: ['country'] });\n      if (!project) {\n        throw new NotFoundException(`Project ID ${projectId} not found`);\n      }\n\n      const vendors = await this.vendorRepository.find();\n      const matches = vendors\n        .filter(vendor => vendor.countries_supported.includes(project.countryId))\n        .map(vendor => {\n          const servicesOverlap = vendor.services_offered.filter(service => project.services_needed.includes(service)).length;\n          const score = servicesOverlap * 2 + vendor.rating + (1 / vendor.response_sla_hours);\n          return {\n            projectId,\n            vendorId: vendor.id,\n            score,\n          };\n        });\n\n      await this.matchRepository.delete({ projectId });\n      return this.factory.create(matches);\n    } catch (error) {\n      this.logger.error(`Failed to rebuild matches for project ID ${projectId}: ${error.message}`);\n      throw error instanceof NotFoundException ? error : new InternalServerErrorException('Failed to rebuild matches');\n    }\n  }\n\n  async getMatchesByProjectId(projectId: number) {\n    return this.factory.getAll({ projectId }, Resource_Name.MATCHES, Models_Name.MATCH);\n  }\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/analytics/analytics.service.ts",
          "instructions": "Update AnalyticsService to join with Countries for top-vendors endpoint. Ensure MongoDB Documents integration remains unchanged.",
          "content": "import { Injectable, InternalServerErrorException, Logger } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Match } from '../matches/entities/match.entity';\nimport { InjectModel } from '@nestjs/mongoose';\nimport { Model } from 'mongoose';\nimport { Document } from '../documents/entities/document.entity';\n\n@Injectable()\nexport class AnalyticsService {\n  private readonly logger = new Logger(AnalyticsService.name);\n\n  constructor(\n    @InjectRepository(Match)\n    private readonly matchRepository: Repository<Match>,\n    @InjectModel(Document.name)\n    private readonly documentModel: Model<Document>,\n  ) {}\n\n  async getTopVendors() {\n    try {\n      const thirtyDaysAgo = new Date();\n      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n\n      const topVendors = await this.matchRepository\n        .createQueryBuilder('match')\n        .select('vendor.id, vendor.name, country.name as country_name, AVG(match.score) as avg_score')\n        .innerJoin('match.vendor', 'vendor')\n        .innerJoin('match.project', 'project')\n        .innerJoin('project.country', 'country')\n        .where('match.createdAt >= :thirtyDaysAgo', { thirtyDaysAgo })\n        .groupBy('vendor.id, vendor.name, country.name')\n        .orderBy('avg_score', 'DESC')\n        .limit(3)\n        .getRawMany();\n\n      const documentCounts = await this.documentModel.aggregate([\n        {\n          $lookup: {\n            from: 'Projects',\n            localField: 'projectId',\n            foreignField: 'id',\n            as: 'project',\n          },\n        },\n        { $unwind: '$project' },\n        {\n          $lookup: {\n            from: 'Countries',\n            localField: 'project.countryId',\n            foreignField: 'id',\n            as: 'country',\n          },\n        },\n        { $unwind: '$country' },\n        {\n          $match: { 'project.status': 'active' },\n        },\n        {\n          $group: {\n            _id: '$country.name',\n            count: { $sum: 1 },\n          },\n        },\n      ]).exec();\n\n      return {\n        topVendors,\n        documentCounts,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to fetch top vendors: ${error.message}`);\n      throw new InternalServerErrorException('Failed to fetch analytics');\n    }\n  }\n}"
        }
      ]
    },
    {
      "taskId": "update-api-features",
      "description": "Update ApiFeatures and HandlerFactory to support joins with Countries and handle countryId/countries_supported as IDs.",
      "actions": [
        {
          "action": "updateFile",
          "filePath": "src/utils/apifeature/api-features.postgres.ts",
          "instructions": "Update ApiFeatures to handle countryId joins for Projects and countries_supported as number[] for Vendors.",
          "content": "import { SelectQueryBuilder } from 'typeorm';\nimport { RESOURCE_CONSTRAINTS } from '../constant';\n\ninterface PaginationMeta {\n  page: number;\n  limit: number;\n  total: number;\n  totalPages: number;\n}\n\nexport class ApiFeatures {\n  private queryBuilder: SelectQueryBuilder<any>;\n  private query: any;\n  private resourceName: keyof typeof RESOURCE_CONSTRAINTS;\n  private alias: string;\n\n  constructor(\n    queryBuilder: SelectQueryBuilder<any>,\n    query: any,\n    resourceName: keyof typeof RESOURCE_CONSTRAINTS,\n    alias: string,\n  ) {\n    this.queryBuilder = queryBuilder;\n    this.query = query;\n    this.resourceName = resourceName;\n    this.alias = alias;\n  }\n\n  filter() {\n    const filterableFields = RESOURCE_CONSTRAINTS[this.resourceName].filterableFields;\n    const whereConditions: string[] = [];\n    const parameters: any = {};\n\n    for (const field of filterableFields) {\n      if (this.query[field]) {\n        if (field === 'country' && this.resourceName === 'PROJECTS') {\n          this.queryBuilder.leftJoinAndSelect(`${this.alias}.country`, 'country');\n          whereConditions.push(`country.name = :${field}`);\n          parameters[field] = this.query[field];\n        } else if (field === 'countries_supported' && this.resourceName === 'VENDORS') {\n          whereConditions.push(`${this.alias}.countries_supported @> :${field}`);\n          parameters[field] = `[\"${this.query[field]}\"]`;\n        } else {\n          whereConditions.push(`${this.alias}.${field} = :${field}`);\n          parameters[field] = this.query[field];\n        }\n      }\n    }\n\n    if (whereConditions.length > 0) {\n      this.queryBuilder.where(whereConditions.join(' AND '), parameters);\n    }\n\n    return this;\n  }\n\n  search() {\n    const searchableFields = RESOURCE_CONSTRAINTS[this.resourceName].searchableFields.map(\n      (field) => (typeof field === 'string' ? field : field.field),\n    );\n    if (this.query.keyword) {\n      const searchConditions: string[] = [];\n      const parameters: any = { keyword: `%${this.query.keyword}%` };\n\n      for (const field of searchableFields) {\n        if (field === 'country' && this.resourceName === 'PROJECTS') {\n          this.queryBuilder.leftJoinAndSelect(`${this.alias}.country`, 'country');\n          searchConditions.push(`country.name ILIKE :keyword`);\n        } else {\n          searchConditions.push(`${this.alias}.${field} ILIKE :keyword`);\n        }\n      }\n\n      if (searchConditions.length > 0) {\n        this.queryBuilder.andWhere(searchConditions.join(' OR '), parameters);\n      }\n    }\n\n    return this;\n  }\n\n  sort() {\n    if (this.query.sort) {\n      const [field, order] = this.query.sort.split(':');\n      this.queryBuilder.orderBy(`${this.alias}.${field}`, order.toUpperCase() === 'DESC' ? 'DESC' : 'ASC');\n    }\n    return this;\n  }\n\n  paginate(totalCount: number) {\n    const page = parseInt(this.query.page, 10) || 1;\n    const limit = parseInt(this.query.limit, 10) || 10;\n    const skip = (page - 1) * limit;\n\n    this.queryBuilder.skip(skip).take(limit);\n\n    return {\n      queryBuilder: this.queryBuilder,\n      pagination: {\n        total: totalCount,\n        page,\n        limit,\n        totalPages: Math.ceil(totalCount / limit),\n      },\n    };\n  }\n\n  getQuery() {\n    return this.queryBuilder;\n  }\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/utils/handlerfactory/handler-factory.postgres.ts",
          "instructions": "Update HandlerFactory to return PaginatedResponse format and handle Countries joins.",
          "content": "import { SelectQueryBuilder, ObjectLiteral, Repository, In } from 'typeorm';\nimport { NotFoundException, InternalServerErrorException } from '@nestjs/common';\nimport { RESOURCE_CONSTRAINTS } from '../constant';\nimport { ApiFeatures } from '../apifeature/api-features.postgres';\nimport { ApiResponseUtil } from '../api-response.util';\n\ninterface PaginationMeta {\n  page: number;\n  limit: number;\n  total: number;\n  totalPages: number;\n}\n\ninterface PaginatedResponse<T> {\n  success: boolean;\n  message: string;\n  data: T[];\n  count: number;\n  pagination: PaginationMeta;\n  timestamp: string;\n}\n\nexport class HandlerFactory<Entity extends ObjectLiteral> {\n  constructor(private readonly repository: Repository<Entity>) {}\n\n  async create(data: any): Promise<Entity | Entity[]> {\n    try {\n      if (Array.isArray(data)) {\n        const entities = this.repository.create(data);\n        return await this.repository.save(entities);\n      } else {\n        const entity = this.repository.create(data as Entity);\n        return await this.repository.save(entity);\n      }\n    } catch (error) {\n      throw ApiResponseUtil.error(`Failed to create: ${error.message}`, 'CREATION_FAILED');\n    }\n  }\n\n  async getOne(id: number): Promise<Entity> {\n    try {\n      const entity = await this.repository.findOne({ where: { id } as any, relations: ['country', 'client'] });\n      if (!entity) throw new NotFoundException(`No ${this.getEntityName()} for this id ${id}`);\n      return entity;\n    } catch (error) {\n      if (error instanceof NotFoundException) throw error;\n      throw ApiResponseUtil.error(`Failed to fetch id ${id}: ${error.message}`, 'RETRIEVAL_FAILED');\n    }\n  }\n\n  async updateOne(id: number, data: any): Promise<Entity> {\n    try {\n      const entity = await this.repository.findOne({ where: { id } as any, relations: ['country', 'client'] });\n      if (!entity) throw new NotFoundException(`No ${this.getEntityName()} for this id ${id}`);\n      Object.assign(entity, data);\n      const updated = await this.repository.save(entity);\n      return updated;\n    } catch (error) {\n      if (error instanceof NotFoundException) throw error;\n      throw ApiResponseUtil.error(`Failed to update id ${id}: ${error.message}`, 'UPDATE_FAILED');\n    }\n  }\n\n  async deleteOne(id: number): Promise<{ message: string; data: Entity; status: string }> {\n    try {\n      const entity = await this.repository.findOne({ where: { id } as any, relations: ['country', 'client'] });\n      if (!entity) throw new NotFoundException(`No ${this.getEntityName()} for this id ${id}`);\n      await this.repository.remove(entity);\n      return ApiResponseUtil.deleted(this.getEntityName(), id);\n    } catch (error) {\n      if (error instanceof NotFoundException) throw error;\n      throw ApiResponseUtil.error(`Failed to delete id ${id}: ${error.message}`, 'DELETION_FAILED');\n    }\n  }\n\n  async getAll(\n    query: any,\n    resourceName: keyof typeof RESOURCE_CONSTRAINTS,\n    alias: string = 'entity',\n  ): Promise<PaginatedResponse<Entity>> {\n    try {\n      const qb = this.repository.createQueryBuilder(alias)\n        .leftJoinAndSelect(`${alias}.country`, 'country')\n        .leftJoinAndSelect(`${alias}.client`, 'client');\n      const apiFeatures = new ApiFeatures(qb, query, resourceName, alias)\n        .filter()\n        .search()\n        .sort();\n\n      const totalCount = await qb.getCount();\n      const { queryBuilder, pagination } = apiFeatures.paginate(totalCount);\n      const data = await queryBuilder.getMany();\n\n      return ApiResponseUtil.successPaginated(data, pagination, `Data retrieved successfully`);\n    } catch (error) {\n      throw ApiResponseUtil.error(`Failed to fetch ${resourceName}: ${error.message}`, 'RETRIEVAL_FAILED');\n    }\n  }\n\n  private getEntityName(): string {\n    const target = this.repository.target as any;\n    return (target?.name ?? target).toLowerCase();\n  }\n}"
        }
      ]
    },
    {
      "taskId": "add-migrations",
      "description": "Create TypeORM migrations for all entities and update package.json scripts.",
      "actions": [
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateUsersTable1720000000000.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateUsersTable1720000000000 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Users\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        username VARCHAR(150),\n        email VARCHAR(250) UNIQUE,\n        password VARCHAR(255) NOT NULL,\n        userType ENUM('CLIENT', 'ADMIN') DEFAULT 'CLIENT',\n        isAccountVerified BOOLEAN DEFAULT FALSE,\n        emailVerificationToken VARCHAR(250),\n        resetPasswordToken VARCHAR(250),\n        resetPasswordTokenExpiresAt TIMESTAMP,\n        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Users\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateClientsTable1720000000001.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateClientsTable1720000000001 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Clients\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        company_name VARCHAR(150),\n        contact_email VARCHAR(250) UNIQUE,\n        userId INT UNIQUE,\n        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n        FOREIGN KEY (userId) REFERENCES Users(id) ON DELETE CASCADE\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Clients\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateCountriesTable1720000000002.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateCountriesTable1720000000002 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Countries\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        name VARCHAR(100) UNIQUE\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Countries\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateServicesTable1720000000003.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateServicesTable1720000000003 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Services\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        name VARCHAR(100) UNIQUE\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Services\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateProjectsTable1720000000004.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateProjectsTable1720000000004 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Projects\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        countryId INT,\n        title VARCHAR(200),\n        description TEXT,\n        services_needed JSON,\n        budget DECIMAL(10,2),\n        status VARCHAR(50) DEFAULT 'PENDING',\n        clientId INT,\n        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n        FOREIGN KEY (clientId) REFERENCES Clients(id) ON DELETE CASCADE,\n        FOREIGN KEY (countryId) REFERENCES Countries(id) ON DELETE RESTRICT\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Projects\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateVendorsTable1720000000005.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateVendorsTable1720000000005 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Vendors\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        name VARCHAR(150),\n        email VARCHAR(250) UNIQUE,\n        countries_supported JSON,\n        services_offered JSON,\n        rating DECIMAL(3,1),\n        response_sla_hours FLOAT,\n        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Vendors\"`);\n  }\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/migrations/CreateMatchesTable1720000000006.ts",
          "content": "import { MigrationInterface, QueryRunner } from 'typeorm';\n\nexport class CreateMatchesTable1720000000006 implements MigrationInterface {\n  public async up(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`\n      CREATE TABLE \"Matches\" (\n        id INT PRIMARY KEY AUTO_INCREMENT,\n        projectId INT,\n        vendorId INT,\n        score DECIMAL(10,2),\n        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\n        FOREIGN KEY (projectId) REFERENCES Projects(id) ON DELETE CASCADE,\n        FOREIGN KEY (vendorId) REFERENCES Vendors(id) ON DELETE CASCADE\n      )\n    `);\n  }\n\n  public async down(queryRunner: QueryRunner): Promise<void> {\n    await queryRunner.query(`DROP TABLE \"Matches\"`);\n  }\n}"
        },
        {
          "action": "updateFile",
          "filePath": "src/config/database/database.config.ts",
          "instructions": "Disable synchronize and enable migrations.",
          "content": "import { ConfigService } from '@nestjs/config';\n\nexport const databaseConfig = (config: ConfigService) => ({\n  type: 'mysql',\n  host: config.get<string>('DATABASE_HOST'),\n  port: config.get<number>('DATABASE_PORT'),\n  username: config.get<string>('DATABASE_USER'),\n  password: config.get<string>('DATABASE_PASSWORD'),\n  database: config.get<string>('DATABASE_NAME'),\n  entities: ['dist/**/*.entity{.ts,.js}'],\n  migrations: ['dist/migrations/*.js'],\n  synchronize: false,\n  migrationsRun: true,\n});"
        },
        {
          "action": "updateFile",
          "filePath": "package.json",
          "instructions": "Add migration scripts to scripts section.",
          "content": "{\n  \"name\": \"market-research-platform\",\n  \"version\": \"1.0.0\",\n  \"scripts\": {\n    \"start\": \"nest start\",\n    \"start:dev\": \"nest start --watch\",\n    \"start:prod\": \"node dist/main\",\n    \"build\": \"nest build\",\n    \"migration:generate\": \"typeorm migration:generate src/migrations/Migration -d src/config/database/database.config.ts\",\n    \"migration:run\": \"typeorm migration:run -d src/config/database/database.config.ts\",\n    \"migration:revert\": \"typeorm migration:revert -d src/config/database/database.config.ts\"\n  },\n  \"dependencies\": {\n    \"@nestjs/common\": \"^9.0.0\",\n    \"@nestjs/core\": \"^9.0.0\",\n    \"@nestjs/typeorm\": \"^9.0.0\",\n    \"@nestjs/mongoose\": \"^9.0.0\",\n    \"typeorm\": \"^0.3.0\",\n    \"mysql2\": \"^2.3.0\",\n    \"mongoose\": \"^6.0.0\"\n  }\n}"
        }
      ]
    },
    {
      "taskId": "add-utils",
      "description": "Add utility files for standardized API responses and error handling.",
      "actions": [
        {
          "action": "createFile",
          "filePath": "src/utils/api-response.types.ts",
          "content": "export interface ApiSuccessResponse<T = any> {\n  success: true;\n  message: string;\n  data: T;\n  count?: number;\n  timestamp: string;\n}\n\nexport interface ApiErrorResponse {\n  success: false;\n  message: string;\n  error?: string;\n  errorCode?: string;\n  timestamp: string;\n}\n\nexport type ApiResponse<T = any> = ApiSuccessResponse<T> | ApiErrorResponse;\n\nexport interface PaginationMeta {\n  page: number;\n  limit: number;\n  total: number;\n  totalPages: number;\n}\n\nexport interface PaginatedResponse<T = any> extends ApiSuccessResponse<T[]> {\n  pagination: PaginationMeta;\n}\n\nexport enum ErrorCodes {\n  NOT_FOUND = 'NOT_FOUND',\n  VALIDATION_ERROR = 'VALIDATION_ERROR',\n  FOREIGN_KEY_CONSTRAINT = 'FOREIGN_KEY_CONSTRAINT',\n  CREATION_FAILED = 'CREATION_FAILED',\n  UPDATE_FAILED = 'UPDATE_FAILED',\n  DELETION_FAILED = 'DELETION_FAILED',\n  RETRIEVAL_FAILED = 'RETRIEVAL_FAILED',\n  FORBIDDEN = 'FORBIDDEN',\n  UNAUTHORIZED = 'UNAUTHORIZED',\n  INTERNAL_ERROR = 'INTERNAL_ERROR'\n}"
        },
        {
          "action": "createFile",
          "filePath": "src/utils/api-response.util.ts",
          "content": "import { ApiSuccessResponse, ApiErrorResponse, PaginatedResponse, PaginationMeta, ErrorCodes } from './api-response.types';\n\nexport class ApiResponseUtil {\n  static success<T>(\n    data: T,\n    message: string = 'Operation completed successfully',\n    count?: number\n  ): ApiSuccessResponse<T> {\n    return {\n      success: true,\n      message,\n      data,\n      count,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  static successWithCount<T>(\n    data: T[],\n    message: string = 'Data retrieved successfully'\n  ): ApiSuccessResponse<T[]> {\n    return {\n      success: true,\n      message,\n      data,\n      count: data.length,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  static successPaginated<T>(\n    data: T[],\n    pagination: PaginationMeta,\n    message: string = 'Data retrieved successfully'\n  ): PaginatedResponse<T> {\n    return {\n      success: true,\n      message,\n      data,\n      count: data.length,\n      pagination,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  static error(\n    message: string,\n    error?: string,\n    errorCode?: string\n  ): ApiErrorResponse {\n    return {\n      success: false,\n      message,\n      error,\n      errorCode,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  static notFound(\n    resource: string,\n    id?: string | number\n  ): ApiErrorResponse {\n    const message = id\n      ? `${resource} with ID ${id} not found`\n      : `${resource} not found`;\n    return this.error(message, 'NOT_FOUND', ErrorCodes.NOT_FOUND);\n  }\n\n  static foreignKeyConstraint(\n    resource: string,\n    details?: string\n  ): ApiErrorResponse {\n    const message = details\n      ? `Foreign key constraint failed for ${resource}: ${details}`\n      : `Foreign key constraint failed for ${resource}`;\n    return this.error(message, 'FOREIGN_KEY_CONSTRAINT', ErrorCodes.FOREIGN_KEY_CONSTRAINT);\n  }\n\n  static updateFailed(\n    resource: string,\n    id: string | number,\n    details?: string\n  ): ApiErrorResponse {\n    const message = details\n      ? `Failed to update ${resource} with ID ${id}: ${details}`\n      : `Failed to update ${resource} with ID ${id}`;\n    return this.error(message, 'UPDATE_FAILED', ErrorCodes.UPDATE_FAILED);\n  }\n\n  static emptyList(\n    resource: string,\n    message?: string\n  ): ApiSuccessResponse<any[]> {\n    return this.successWithCount(\n      [],\n      message || `No ${resource} found`\n    );\n  }\n\n  static deleted(\n    resource: string,\n    id: string | number,\n    additionalInfo?: string\n  ): ApiSuccessResponse<{ deletedId: string | number; additionalInfo?: string }> {\n    return this.success(\n      { deletedId: id, additionalInfo },\n      `${resource} with ID ${id} has been successfully deleted`\n    );\n  }\n\n  static created<T>(\n    data: T,\n    resource: string\n  ): ApiSuccessResponse<T> {\n    return this.success(\n      data,\n      `${resource} created successfully`\n    );\n  }\n\n  static updated<T>(\n    data: T,\n    resource: string\n  ): ApiSuccessResponse<T> {\n    return this.success(\n      data,\n      `${resource} updated successfully`\n    );\n  }\n}"
        }
      ]
    },
    {
      "taskId": "update-modules",
      "description": "Update module files to include new entities.",
      "actions": [
        {
          "action": "updateFile",
          "filePath": "src/modules/projects/projects.module.ts",
          "instructions": "Add Countries to TypeOrmModule.forFeature.",
          "content": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { ProjectsService } from './projects.service';\nimport { ProjectsController } from './projects.controller';\nimport { Project } from './entities/project.entity';\nimport { Country } from '../entities/countries.entity';\nimport { HandlerFactory } from '../../utils/handlerfactory/handler-factory.postgres';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([Project, Country])],\n  controllers: [ProjectsController],\n  providers: [ProjectsService, HandlerFactory],\n  exports: [ProjectsService],\n})\nexport class ProjectsModule {}"
        },
        {
          "action": "updateFile",
          "filePath": "src/modules/vendors/vendors.module.ts",
          "instructions": "Add Countries to TypeOrmModule.forFeature.",
          "content": "import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { VendorsService } from './vendors.service';\nimport { VendorsController } from './vendors.controller';\nimport { Vendor } from './entities/vendor.entity';\nimport { Country } from '../entities/countries.entity';\nimport { HandlerFactory } from '../../utils/handlerfactory/handler-factory.postgres';\n\n@Module({\n  imports: [TypeOrmModule.forFeature([Vendor, Country])],\n  controllers: [VendorsController],\n  providers: [VendorsService, HandlerFactory],\n  exports: [VendorsService],\n})\nexport class VendorsModule {}"
        }
      ]
    },
    {
      "taskId": "notes",
      "description": "Additional notes for implementation.",
      "notes": [
        "Ensure all services (ProjectsService, VendorsService, MatchesService, AnalyticsService) use ApiResponseUtil for standardized responses.",
        "Documents are stored in MongoDB, so ensure no changes affect the MongoDB schema or DocumentsService.",
        "Validate countryId and countries_supported against Countries table in all CRUD operations.",
        "Test all endpoints after changes, especially GET /api/v1/projects?country=Egypt and GET /api/v1/vendors?countries_supported=1.",
        "Run migrations using `npm run migration:run` after updating the schema.",
        "Ensure RESOURCE_CONSTRAINTS in src/utils/constant.ts includes 'country' for Projects and 'countries_supported' for Vendors as filterable/searchable fields."
      ]
    }
  ]
}